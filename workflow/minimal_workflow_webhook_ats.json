{
  "name": "Resume Enhancer Minimal + ATS",
  "nodes": [
    {"id": "webhook", "name": "Webhook", "type": "n8n-nodes-base.webhook", "typeVersion": 2, "position": [0, 0], "webhookId": "resume-enhance-ats", "parameters": {"path": "resume-enhance-ats", "httpMethod": "POST", "responseMode": "lastNode", "options": {}}},
    {"id": "input", "name": "User Input", "type": "n8n-nodes-base.set", "typeVersion": 3.4, "position": [220, 0], "parameters": {"mode": "raw", "jsonOutput": "={\n  \"resume_path\": \"{{ ($json.body && $json.body.resume_path) ? $json.body.resume_path : ($json.resume_path || '/data/input/master_resume.pdf') }}\",\n  \"job_url\": \"{{ ($json.body && $json.body.job_url) ? $json.body.job_url : ($json.job_url || '') }}\",\n  \"jd_text\": {{ JSON.stringify(($json.body && $json.body.jd_text) ? $json.body.jd_text : ($json.jd_text || '')) }},\n  \"language\": \"{{ ($json.body && $json.body.language) ? $json.body.language : ($json.language || 'en') }}\",\n  \"tone\": \"{{ ($json.body && $json.body.tone) ? $json.body.tone : ($json.tone || 'professional') }}\",\n  \"pages\": {{ ($json.body && $json.body.pages) ? $json.body.pages : ($json.pages || 1) }},\n  \"debug_received\": {{ JSON.stringify($json) }}\n}", "options": {}}},
    {"id": "checkJdSource", "name": "Check JD Source", "type": "n8n-nodes-base.if", "typeVersion": 2, "position": [440, 0], "parameters": {"conditions": {"options": {"version": 2, "leftValue": "", "caseSensitive": true, "typeValidation": "strict"}, "combinator": "and", "conditions": [{"id": "1", "leftValue": "={{ $json.job_url }}", "rightValue": "", "operator": {"type": "string", "operation": "notEmpty"}}]}}},
    {"id": "fetchJd", "name": "Fetch Job Description", "type": "n8n-nodes-base.httpRequest", "typeVersion": 4.2, "position": [660, -100], "continueOnFail": true, "parameters": {"method": "GET", "url": "=https://r.jina.ai/{{ encodeURIComponent($json.job_url) }}", "options": {"timeout": 60000}, "headers": {"parameters": [{"name": "Accept", "value": "text/plain"}]}}},
    {"id": "extractJd", "name": "Extract JD", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [880, -100], "parameters": {"jsCode": "const input = $('User Input').item.json;\nconst fetchResult = $input.first().json;\n\n// Check if fetch failed (continueOnFail passes error info)\nlet jdText = '';\nlet jdSource = 'fetched';\nlet fetchError = null;\n\nif (fetchResult.error || fetchResult.code === 'ECONNABORTED') {\n  // Fetch failed - timeout or blocked\n  fetchError = fetchResult.error?.message || fetchResult.message || 'Request timed out or blocked';\n  jdText = '';\n  jdSource = 'fetch_failed';\n} else {\n  // Try to extract text\n  const fetchedText = fetchResult.data || fetchResult.body || '';\n  jdText = String(fetchedText).trim();\n  \n  if (jdText.length < 100) {\n    jdText = '';\n    jdSource = 'fetch_failed';\n    fetchError = 'Response too short or empty';\n  }\n}\n\nreturn [{\n  json: {\n    ...input,\n    jd_text: jdText,\n    jd_source: jdSource,\n    fetch_error: fetchError\n  }\n}];"}},
    {"id": "useManualJd", "name": "Use Manual JD", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [660, 100], "parameters": {"jsCode": "const input = $('User Input').item.json;\nreturn [{\n  json: {\n    ...input,\n    jd_source: 'manual'\n  }\n}];"}},
    {"id": "readResume", "name": "Read Resume", "type": "n8n-nodes-base.readBinaryFiles", "typeVersion": 1, "position": [1100, 0], "parameters": {"fileSelector": "={{ $json.resume_path }}"}},
    {"id": "extractText", "name": "Extract PDF Text", "type": "n8n-nodes-base.extractFromFile", "typeVersion": 1, "position": [1320, 0], "parameters": {"operation": "pdf", "binaryPropertyName": "data", "options": {}}},
    {"id": "mergeJdData", "name": "Merge JD Data", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [1430, 0], "parameters": {"jsCode": "// Merge extracted resume text with JD data\nconst resumeText = $input.first().json.text || '';\n\n// Get JD text from upstream - try both paths\nlet jdText = '';\nlet jdSource = 'manual';\nlet fetchError = null;\n\ntry {\n  const extractJd = $('Extract JD').item.json;\n  jdText = extractJd.jd_text || '';\n  jdSource = extractJd.jd_source || 'fetched';\n  fetchError = extractJd.fetch_error || null;\n} catch (e) {\n  // Extract JD wasn't executed\n}\n\nif (!jdText) {\n  try {\n    const manualJd = $('Use Manual JD').item.json;\n    jdText = manualJd.jd_text || '';\n    jdSource = manualJd.jd_source || 'manual';\n  } catch (e) {\n    // Use Manual JD wasn't executed\n  }\n}\n\nreturn [{\n  json: {\n    text: resumeText,\n    jd_text: jdText,\n    jd_source: jdSource,\n    fetch_error: fetchError\n  }\n}];"}},
    {"id": "parseResume", "name": "Parse Resume", "type": "@n8n/n8n-nodes-langchain.openAi", "typeVersion": 1.8, "position": [1540, 0], "parameters": {"resource": "text", "operation": "message", "modelId": {"__rl": true, "mode": "list", "value": "gpt-4o-mini"}, "messages": {"values": [{"content": "=You are an expert resume parser. Extract structured data from this resume text.\n\nResume text:\n{{ $json.text }}\n\nReturn JSON with these fields:\n{\n  \"name\": \"Full Name\",\n  \"title\": \"Current/Target Job Title\",\n  \"contact\": { \"email\": \"\", \"phone\": \"\", \"location\": \"\", \"linkedin\": \"\", \"github\": \"\" },\n  \"summary\": \"Professional summary\",\n  \"experience\": [{ \"title\": \"\", \"company\": \"\", \"location\": \"\", \"dates\": \"\", \"bullets\": [] }],\n  \"education\": [{ \"degree\": \"\", \"school\": \"\", \"dates\": \"\", \"gpa\": \"\" }],\n  \"skills\": { \"technical\": [], \"frameworks\": [], \"tools\": [], \"soft\": [] },\n  \"certifications\": []\n}"}]}, "options": {"responseFormat": "json_object"}, "simplify": true}, "credentials": {"openAiApi": {"id": "vcJ5TpL46HLa4xpq", "name": "OpenAi account"}}},
    {"id": "enhance", "name": "Enhance Resume", "type": "@n8n/n8n-nodes-langchain.openAi", "typeVersion": 1.8, "position": [1760, 0], "parameters": {"resource": "text", "operation": "message", "modelId": {"__rl": true, "mode": "list", "value": "gpt-4o"}, "messages": {"values": [{"content": "=STEP 1: Determine candidate level based on years of experience, job titles, and responsibility complexity:\n- JUNIOR (0-2 years): Entry-level tasks, learning, assisting\n- MID (2-5 years): Independent work, some ownership\n- SENIOR (5+ years): Leadership, architecture, mentoring\n\nSTEP 2: Enhance resume ONLY within the candidate's level.\n\nABSOLUTE RULES - VIOLATION = FAILURE:\n1. NEVER add numbers, percentages, or metrics NOT in original\n2. NEVER add team sizes, revenue, or user counts NOT in original\n3. NEVER add technologies NOT mentioned in original\n4. NEVER claim achievements above candidate's level:\n   - Junior cannot \"led team\" or \"architected system\"\n   - Mid cannot \"saved company $5M\" or \"managed department\"\n5. NEVER add outcomes that weren't stated\n\nALLOWED:\n- Replace weak verbs with action verbs appropriate to level\n- Add JD keywords IF the underlying skill exists in original\n- Rephrase for clarity and impact\n- Highlight relevant existing experience\n\nEXAMPLES:\nJUNIOR Original: \"Helped with code reviews\"\n OK: \"Participated in code review process\"\n WRONG: \"Conducted 50+ code reviews, reducing bugs by 30%\"\n\nMID Original: \"Worked on backend features\"\n OK: \"Developed backend features\"\n WRONG: \"Architected scalable microservices handling 1M requests\"\n\nSENIOR Original: \"Led development team\"\n OK: \"Directed software development initiatives\"\n WRONG: \"Led team of 25 engineers\" (if number not in original)\n\n---\nOriginal Resume:\n{{ JSON.stringify($json.message?.content || $json) }}\n\nJob Description (for keywords only):\n{{ $('Merge JD Data').item.json.jd_text.substring(0, 4000) }}\n\nReturn ONLY this JSON:\n{\"detected_level\":\"junior|mid|senior\",\"enhanced_resume\":{\"name\":\"...\",\"title\":\"...\",\"contact\":{\"email\":\"...\",\"phone\":\"...\",\"location\":\"...\"},\"summary\":\"...\",\"experience\":[{\"title\":\"...\",\"company\":\"...\",\"dates\":\"...\",\"bullets\":[\"...\"]}],\"education\":[{\"degree\":\"...\",\"school\":\"...\",\"dates\":\"...\"}],\"skills\":{\"technical\":[],\"frameworks\":[],\"tools\":[]},\"certifications\":[]}}"}]}, "options": {"responseFormat": "json_object"}, "simplify": true}, "credentials": {"openAiApi": {"id": "vcJ5TpL46HLa4xpq", "name": "OpenAi account"}}},
    {"id": "verify", "name": "Verify Resume", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [1980, 0], "parameters": {"jsCode": "// Parse the enhance resume output\nconst input = $input.first().json;\nlet enhancedData;\n\nconst stripMarkdown = (s) => s.replace(/^```json\\s*/i, '').replace(/```\\s*$/i, '').trim();\n\n// Get the content from enhance resume\nlet content = input.message?.content || input.content || input;\nif (typeof content === 'string') {\n  try {\n    content = stripMarkdown(content);\n    enhancedData = JSON.parse(content);\n  } catch (e) {\n    throw new Error('Failed to parse Enhance Resume output: ' + content.substring(0, 200));\n  }\n} else {\n  enhancedData = content;\n}\n\nconst detectedLevel = enhancedData.detected_level || 'mid';\nconst enhancedResume = enhancedData.enhanced_resume || enhancedData;\n\n// Get original resume from Parse Resume\nlet originalContent = $('Parse Resume').item.json.message?.content;\nlet originalResume;\nif (typeof originalContent === 'string') {\n  try {\n    originalContent = stripMarkdown(originalContent);\n    originalResume = JSON.parse(originalContent);\n  } catch (e) {\n    originalResume = { raw: originalContent };\n  }\n} else {\n  originalResume = originalContent;\n}\n\n// Pass data to next node (verification will be done by LLM)\nreturn [{\n  json: {\n    detected_level: detectedLevel,\n    enhanced_resume: enhancedResume,\n    original_resume: originalResume\n  }\n}];"}},
    {"id": "verifyLlm", "name": "Verify LLM", "type": "@n8n/n8n-nodes-langchain.openAi", "typeVersion": 1.8, "position": [2200, 0], "parameters": {"resource": "text", "operation": "message", "modelId": {"__rl": true, "mode": "list", "value": "gpt-4o-mini"}, "messages": {"values": [{"content": "=You are a JSON-only fact-checker. You MUST respond with ONLY valid JSON.\n\nORIGINAL RESUME:\n{{ JSON.stringify($json.original_resume) }}\n\nENHANCED RESUME:\n{{ JSON.stringify($json.enhanced_resume) }}\n\nDETECTED LEVEL: {{ $json.detected_level }}\n\nCheck each bullet point for fabrications:\n1. Added numbers/metrics NOT in original = violation\n2. Added technologies NOT in original = violation\n3. Claims above candidate level = violation\n\nFor violations: revert to truthful version using ONLY original facts.\n\nReturn ONLY this JSON:\n{\"verified\":true,\"violations_found\":0,\"corrected_resume\":{\"name\":\"...\",\"title\":\"...\",\"contact\":{\"email\":\"...\",\"phone\":\"...\",\"location\":\"...\"},\"summary\":\"...\",\"experience\":[{\"title\":\"...\",\"company\":\"...\",\"dates\":\"...\",\"bullets\":[\"...\"]}],\"education\":[{\"degree\":\"...\",\"school\":\"...\",\"dates\":\"...\"}],\"skills\":{\"technical\":[],\"frameworks\":[],\"tools\":[]},\"certifications\":[]}}\n\nIf no violations, copy enhanced_resume into corrected_resume unchanged."}]}, "options": {"responseFormat": "json_object"}, "simplify": true}, "credentials": {"openAiApi": {"id": "vcJ5TpL46HLa4xpq", "name": "OpenAi account"}}},
    {"id": "prepareAts", "name": "Prepare ATS Input", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [2420, 0], "parameters": {"jsCode": "// Parse Verify LLM output and prepare for ATS analysis\nconst input = $input.first().json;\n\nconst stripMarkdown = (s) => s.replace(/^```json\\s*/i, '').replace(/```\\s*$/i, '').trim();\n\n// Parse verify output\nlet verifyContent = input.message?.content || input;\nif (typeof verifyContent === 'string') {\n  try {\n    verifyContent = stripMarkdown(verifyContent);\n    verifyContent = JSON.parse(verifyContent);\n  } catch (e) {\n    throw new Error('Failed to parse Verify LLM response: ' + String(verifyContent).substring(0, 200));\n  }\n}\n\nconst correctedResume = verifyContent.corrected_resume || verifyContent;\nconst verified = verifyContent.verified;\nconst violationsFound = verifyContent.violations_found || 0;\n\n// Get JD text from Merge JD Data node (already collected from upstream)\nconst jdText = $('Merge JD Data').item.json.jd_text || '';\nconst jdLength = jdText.length;\n\n// Calculate resume text length for stats\nlet resumeText = '';\nif (correctedResume.summary) resumeText += correctedResume.summary + ' ';\nif (correctedResume.experience) {\n  correctedResume.experience.forEach(exp => {\n    if (exp.bullets) resumeText += exp.bullets.join(' ') + ' ';\n  });\n}\nif (correctedResume.skills) {\n  Object.values(correctedResume.skills).forEach(arr => {\n    if (Array.isArray(arr)) resumeText += arr.join(' ') + ' ';\n  });\n}\nconst resumeLength = resumeText.length;\n\nreturn [{\n  json: {\n    corrected_resume: correctedResume,\n    verified: verified,\n    violations_found: violationsFound,\n    jd_text: jdText,\n    jd_length: jdLength,\n    resume_length: resumeLength\n  }\n}];"}},
    {"id": "atsAnalyzer", "name": "ATS Analyzer", "type": "@n8n/n8n-nodes-langchain.openAi", "typeVersion": 1.8, "position": [2640, 0], "parameters": {"resource": "text", "operation": "message", "modelId": {"__rl": true, "mode": "list", "value": "gpt-4o-mini"}, "messages": {"values": [{"content": "=You are an ATS (Applicant Tracking System) keyword analyzer. You MUST respond with ONLY valid JSON.\n\nJOB DESCRIPTION:\n{{ $json.jd_text.substring(0, 6000) }}\n\nRESUME:\n{{ JSON.stringify($json.corrected_resume) }}\n\nTASK:\n1. Extract 20-60 important keywords from the Job Description:\n   - Hard skills (technologies, languages, cloud, databases, frameworks)\n   - Tools (CI/CD, Terraform, Jira, etc.)\n   - Role-specific terms (SRE, IAM, DevOps, etc.)\n   - Methodologies (Agile, ITIL, Scrum)\n   - DO NOT include generic soft skills like \"team player\", \"communication\", \"fast-paced\"\n   - Remove duplicates and overly generic words\n\n2. Check which keywords appear in the resume (summary, skills, experience bullets, title)\n   - Consider synonyms (e.g., \"CI/CD\" matches \"continuous integration\")\n   - Case-insensitive matching\n\n3. Calculate ATS score: round(matched / total * 100)\n\nReturn ONLY this JSON:\n{\n  \"keywords\": [\"keyword1\", \"keyword2\", ...],\n  \"matched_keywords\": [\"keyword1\", ...],\n  \"missing_keywords\": [\"keyword2\", ...],\n  \"ats_score\": 75,\n  \"notes\": \"Brief 1-2 sentence recommendation. DO NOT suggest adding skills not in the original resume.\"\n}\n\nIMPORTANT:\n- keywords array: 20-60 items\n- matched_keywords + missing_keywords should equal keywords (no overlap)\n- ats_score: integer 0-100\n- If JD is too short (<200 chars), return ats_score: null and notes explaining why"}]}, "options": {"responseFormat": "json_object"}, "simplify": true}, "credentials": {"openAiApi": {"id": "vcJ5TpL46HLa4xpq", "name": "OpenAi account"}}},
    {"id": "mergeAts", "name": "Merge ATS Data", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [2860, 0], "parameters": {"jsCode": "// Merge ATS analysis with resume data\nconst input = $input.first().json;\nconst prepareAts = $('Prepare ATS Input').item.json;\n\nconst stripMarkdown = (s) => s.replace(/^```json\\s*/i, '').replace(/```\\s*$/i, '').trim();\n\n// Parse ATS analyzer output\nlet atsContent = input.message?.content || input;\nif (typeof atsContent === 'string') {\n  try {\n    atsContent = stripMarkdown(atsContent);\n    atsContent = JSON.parse(atsContent);\n  } catch (e) {\n    // ATS analysis failed - use fallback\n    atsContent = {\n      keywords: [],\n      matched_keywords: [],\n      missing_keywords: [],\n      ats_score: null,\n      notes: 'ATS analysis failed to parse. Resume still generated successfully.'\n    };\n  }\n}\n\n// Handle case where JD was too short\nif (prepareAts.jd_length < 200) {\n  atsContent = {\n    keywords: [],\n    matched_keywords: [],\n    missing_keywords: [],\n    ats_score: null,\n    notes: 'JD too short or unavailable for ATS analysis.'\n  };\n}\n\n// Build ATS object\nconst ats = {\n  ats_score: atsContent.ats_score,\n  matched_keywords: atsContent.matched_keywords || [],\n  missing_keywords: atsContent.missing_keywords || [],\n  notes: atsContent.notes || ''\n};\n\nreturn [{\n  json: {\n    corrected_resume: prepareAts.corrected_resume,\n    verified: prepareAts.verified,\n    violations_found: prepareAts.violations_found,\n    jd_length: prepareAts.jd_length,\n    resume_length: prepareAts.resume_length,\n    ats: ats,\n    keyword_count_matched: ats.matched_keywords.length,\n    keyword_count_missing: ats.missing_keywords.length,\n    keyword_count_total: (atsContent.keywords || []).length\n  }\n}];"}},
    {"id": "buildHtml", "name": "Build HTML", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [3080, 0], "parameters": {"jsCode": "// Get the merged data with ATS info\nconst input = $input.first().json;\nconst r = input.corrected_resume;\n\nif (!r || !r.name) {\n  throw new Error('No corrected_resume found in input');\n}\n\nconst esc = (s) => String(s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\nconst html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body { font-family: 'Arial', sans-serif; font-size: 11pt; line-height: 1.4; color: #333; padding: 0.5in; max-width: 8.5in; }\n    h1 { font-size: 18pt; color: #1a1a1a; margin-bottom: 2px; }\n    .title { font-size: 12pt; color: #555; margin-bottom: 8px; }\n    .contact { font-size: 9pt; color: #666; margin-bottom: 15px; }\n    h2 { font-size: 12pt; border-bottom: 1px solid #ccc; padding-bottom: 3px; margin: 15px 0 8px 0; text-transform: uppercase; }\n    .job { margin-bottom: 12px; }\n    .job-header { display: flex; justify-content: space-between; margin-bottom: 3px; }\n    .job-title { font-weight: bold; }\n    ul { margin-left: 18px; margin-top: 3px; }\n    li { margin-bottom: 2px; }\n    .edu { margin-bottom: 8px; }\n    .skills { display: flex; flex-wrap: wrap; gap: 15px; }\n    .skill-group { flex: 1; min-width: 200px; }\n    .skill-label { font-weight: bold; font-size: 10pt; }\n  </style>\n</head>\n<body>\n  <h1>${esc(r.name)}</h1>\n  <div class=\"title\">${esc(r.title)}</div>\n  <div class=\"contact\">\n    ${r.contact?.email || ''} ${r.contact?.phone ? ' | ' + r.contact.phone : ''} ${r.contact?.location ? ' | ' + r.contact.location : ''}\n  </div>\n  ${r.summary ? '<h2>Summary</h2><p>' + esc(r.summary) + '</p>' : ''}\n  ${r.experience?.length ? '<h2>Experience</h2>' + r.experience.map(j => '<div class=\"job\"><div class=\"job-header\"><span class=\"job-title\">' + esc(j.title) + ' | ' + esc(j.company) + '</span><span>' + esc(j.dates) + '</span></div>' + (j.bullets?.length ? '<ul>' + j.bullets.map(b => '<li>' + esc(b) + '</li>').join('') + '</ul>' : '') + '</div>').join('') : ''}\n  ${r.education?.length ? '<h2>Education</h2>' + r.education.map(e => '<div class=\"edu\"><strong>' + esc(e.degree) + '</strong> - ' + esc(e.school) + (e.dates ? ' | ' + esc(e.dates) : '') + '</div>').join('') : ''}\n  ${r.skills ? '<h2>Skills</h2><div class=\"skills\">' + Object.entries(r.skills).filter(([k,v]) => v?.length).map(([k,v]) => '<div class=\"skill-group\"><span class=\"skill-label\">' + k + ':</span> ' + v.join(', ') + '</div>').join('') + '</div>' : ''}\n  ${r.certifications?.length ? '<h2>Certifications</h2><ul>' + r.certifications.map(c => '<li>' + esc(c) + '</li>').join('') + '</ul>' : ''}\n</body>\n</html>`;\n\n// Pass through all data including ATS\nreturn [{ \n  json: { \n    html, \n    resume: r, \n    verified: input.verified, \n    violations_found: input.violations_found,\n    ats: input.ats,\n    jd_length: input.jd_length,\n    resume_length: input.resume_length,\n    keyword_count_matched: input.keyword_count_matched,\n    keyword_count_missing: input.keyword_count_missing,\n    keyword_count_total: input.keyword_count_total\n  } \n}];"}},
    {"id": "prepareFile", "name": "Prepare PDF File", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [3300, 0], "parameters": {"jsCode": "const input = $input.first().json;\nconst html = input.html;\nconst htmlBuffer = Buffer.from(html, 'utf-8');\n\nreturn [{\n  json: { \n    resume: input.resume,\n    verified: input.verified,\n    violations_found: input.violations_found,\n    ats: input.ats,\n    jd_length: input.jd_length,\n    resume_length: input.resume_length,\n    keyword_count_matched: input.keyword_count_matched,\n    keyword_count_missing: input.keyword_count_missing,\n    keyword_count_total: input.keyword_count_total\n  },\n  binary: {\n    'index.html': {\n      data: htmlBuffer.toString('base64'),\n      mimeType: 'text/html',\n      fileName: 'index.html'\n    }\n  }\n}];"}},
    {"id": "sendToPdf", "name": "Convert to PDF", "type": "n8n-nodes-base.httpRequest", "typeVersion": 4.2, "position": [3520, 0], "parameters": {"method": "POST", "url": "http://gotenberg:3000/forms/chromium/convert/html", "sendBody": true, "contentType": "multipart-form-data", "bodyParameters": {"parameters": [{"parameterType": "formBinaryData", "name": "files", "inputDataFieldName": "index.html"}]}, "options": {"response": {"response": {"responseFormat": "file", "outputPropertyName": "pdf"}}}}},
    {"id": "writePdf", "name": "Write PDF", "type": "n8n-nodes-base.writeBinaryFile", "typeVersion": 1, "position": [3740, 0], "parameters": {"fileName": "=/data/output/improved_resume.pdf", "dataPropertyName": "pdf", "options": {}}},
    {"id": "summary", "name": "Summary", "type": "n8n-nodes-base.code", "typeVersion": 2, "position": [3960, 0], "parameters": {"jsCode": "const prepareFile = $('Prepare PDF File').item.json;\nconst resume = prepareFile.resume;\nconst mergeJdData = $('Merge JD Data').item.json;\nconst jdSource = mergeJdData.jd_source;\nconst fetchError = mergeJdData.fetch_error;\n\n// Build response with ATS data\nconst response = {\n  success: true,\n  name: resume?.name,\n  title: resume?.title,\n  jd_source: jdSource,\n  verified: prepareFile.verified,\n  violations_corrected: prepareFile.violations_found || 0,\n  output_file: '/data/output/improved_resume.pdf',\n  \n  // ATS metrics\n  ats: prepareFile.ats || {\n    ats_score: null,\n    matched_keywords: [],\n    missing_keywords: [],\n    notes: 'ATS analysis not available'\n  },\n  \n  // Additional stats\n  jd_length: prepareFile.jd_length || 0,\n  resume_length: prepareFile.resume_length || 0,\n  keyword_count_matched: prepareFile.keyword_count_matched || 0,\n  keyword_count_missing: prepareFile.keyword_count_missing || 0,\n  keyword_count_total: prepareFile.keyword_count_total || 0,\n  \n  // Fetch error if any\n  fetch_error: fetchError,\n  \n  // Message\n  message: prepareFile.ats?.ats_score !== null \n    ? `Resume enhanced. ATS Score: ${prepareFile.ats.ats_score}%. ${prepareFile.keyword_count_matched} keywords matched, ${prepareFile.keyword_count_missing} missing.`\n    : fetchError \n      ? `Resume enhanced. ATS unavailable: ${fetchError}. LinkedIn and some sites block automated access - use jd_text instead.`\n      : 'Resume enhanced. ATS analysis unavailable (JD too short or missing).'\n};\n\nreturn [{ json: response }];"}}
  ],
  "connections": {
    "Webhook": {"main": [[{"node": "User Input", "type": "main", "index": 0}]]},
    "User Input": {"main": [[{"node": "Check JD Source", "type": "main", "index": 0}]]},
    "Check JD Source": {"main": [[{"node": "Fetch Job Description", "type": "main", "index": 0}], [{"node": "Use Manual JD", "type": "main", "index": 0}]]},
    "Fetch Job Description": {"main": [[{"node": "Extract JD", "type": "main", "index": 0}]]},
    "Extract JD": {"main": [[{"node": "Read Resume", "type": "main", "index": 0}]]},
    "Use Manual JD": {"main": [[{"node": "Read Resume", "type": "main", "index": 0}]]},
    "Read Resume": {"main": [[{"node": "Extract PDF Text", "type": "main", "index": 0}]]},
    "Extract PDF Text": {"main": [[{"node": "Merge JD Data", "type": "main", "index": 0}]]},
    "Merge JD Data": {"main": [[{"node": "Parse Resume", "type": "main", "index": 0}]]},
    "Parse Resume": {"main": [[{"node": "Enhance Resume", "type": "main", "index": 0}]]},
    "Enhance Resume": {"main": [[{"node": "Verify Resume", "type": "main", "index": 0}]]},
    "Verify Resume": {"main": [[{"node": "Verify LLM", "type": "main", "index": 0}]]},
    "Verify LLM": {"main": [[{"node": "Prepare ATS Input", "type": "main", "index": 0}]]},
    "Prepare ATS Input": {"main": [[{"node": "ATS Analyzer", "type": "main", "index": 0}]]},
    "ATS Analyzer": {"main": [[{"node": "Merge ATS Data", "type": "main", "index": 0}]]},
    "Merge ATS Data": {"main": [[{"node": "Build HTML", "type": "main", "index": 0}]]},
    "Build HTML": {"main": [[{"node": "Prepare PDF File", "type": "main", "index": 0}]]},
    "Prepare PDF File": {"main": [[{"node": "Convert to PDF", "type": "main", "index": 0}]]},
    "Convert to PDF": {"main": [[{"node": "Write PDF", "type": "main", "index": 0}]]},
    "Write PDF": {"main": [[{"node": "Summary", "type": "main", "index": 0}]]}
  },
  "settings": {"executionOrder": "v1"}
}
